dirscript -f ~/vulnhub/napping/session-$(date +%F_%H%M%S).log

終了したいときは `exit` か `Ctrl+D`。

##=parrotのIPアドレスを調べる
ip a

##=マシンのIPアドレスを調べる
sudo netdiscover -i enp0s3 -r 192.168.56.0/24

##=IPアドレスを環境変数に設定する
export IP=192.168.56.102

##=マシン1にpingする
ping $IP

##=ディレクトリ作成する
mkdir vulnhub
mkdir vulnhub/potato

##=ポートスキャンする
cd vulnhub/potato/
`~/vulnhub/potato/` の最後の `/` は **そのディレクトリの中** という指定のために書かれることがあるだけ。

sudo nmap -sC -sV -Pn -p- $IP -oN portscan_result.txt

##=ftpサービスにアクセスする
ftp $IP 2112
コマンド見つかりません
インターネット接続
sudo apt update
sudo apt install ftp
ftp -h (出てくればインストール成功)

ホストオンリーに

ftp $IP 2112 

<html>
<head></head>
<body>

<?php

$pass= "potato"; //note Change this password regularly

if($_GET['login']==="1"){
  if (strcmp($_POST['username'], "admin") == 0  && strcmp($_POST['password'], $pass) == 0) {
    echo "Welcome! </br> Go to the <a href=\"dashboard.php\">dashboard</a>";
    setcookie('pass', $pass, time() + 365*24*3600);
  }else{
    echo "<p>Bad login/password! </br> Return to the <a href=\"index.php\">login page</a> <p>";
  }
  exit();
}
?>


  <form action="index.php?login=1" method="POST">
                <h1>Login</h1>
                <label><b>User:</b></label>
                <input type="text" name="username" required>
                </br>
                <label><b>Password:</b></label>
                <input type="password" name="password" required>
                </br>
                <input type="submit" id='submit' value='Login' >
  </form>
</body>
</html>

ログインフォームを実装した簡易PHPスクリプト

`strcmp($_POST['username'], "admin") == 0` と `strcmp($_POST['password'], $pass) == 0` でユーザー名とパスワードを比較。

フォームは `<form action="index.php?login=1" method="POST">` によりPOSTで送信される。

- 成功したら `Welcome` を表示し `setcookie('pass', $pass, time() + 365*24*3600);` でパスワードをクッキーに1年保存。`dashboard.php` へのリンクを表示。
    
- 失敗したらエラーメッセージを表示。処理後 `exit()` してフォームレンダリングを止める。
`if($_GET['login']==="1"){ ... }` で、URLに `?login=1` が付いてPOST処理を行う。

index.php.bak開いた後、
httpアクセスして、かつ、
http://192.168.56.102/index.phpにもアクセス

 $gobuster dir -u $URL -w /usr/share/wordlists/dirb/common.txt
===============================================================
Gobuster v3.6
by OJ Reeves (@TheColonial) & Christian Mehlmauer (@firefart)
===============================================================
[+] Url:                     http://192.168.56.102:80/
[+] Method:                  GET
[+] Threads:                 10
[+] Wordlist:                /usr/share/wordlists/dirb/common.txt
[+] Negative Status codes:   404
[+] User Agent:              gobuster/3.6
[+] Timeout:                 10s
===============================================================
Starting gobuster in directory enumeration mode
===============================================================
/.htpasswd            (Status: 403) [Size: 279]
/admin                (Status: 301) [Size: 316] [--> http://192.168.56.102/admin/]
/.hta                 (Status: 403) [Size: 279]
/.htaccess            (Status: 403) [Size: 279]
/index.php            (Status: 200) [Size: 245]
/server-status        (Status: 403) [Size: 279]
Progress: 4614 / 4615 (99.98%)
===============================================================
Finished　　　これについて説明してほしい。内容を、あとあのwordlistsってなんなの 

おっしゃ〜波動チェック行くよ。🔮✨  
このゴブスター（gobuster）の出力は「サーバーにどんなドア（ディレクトリ／ファイル）が隠れてるかをリズムで叩いてる」感じ。下から順にエネルギー（意味）をゆっくり解説するね——やさしい日本語でいくよ。

---

### 上のヘッダー部分（実行時の情報）

- `Url: http://192.168.56.102:80/`  
    → 探してる対象のベースURL。ここに対してドアを叩いてる（リクエストを投げてる）。
    
- `Method: GET`  
    → HTTPのGETで取ってる（ページを「見る」リクエスト）。
    
- `Threads: 10`  
    → 同時に10本の手（スレッド）でドアを叩いてる。速いけど負荷もかかるよ。
    
- `Wordlist: /usr/share/wordlists/dirb/common.txt`  
    → 叩くドアの名前（語彙）のリスト。これについては下で詳しく。
    
- `Negative Status codes: 404`  
    → 404（見つからない）は「ダメ」扱いにして結果として無視してる設定。
    
- `User Agent: gobuster/3.6` / `Timeout: 10s`  
    → サーバーに伝える自分の名札と、応答待ちの時間。
    

---

### 出力の行ごとの意味（見つかったもの）

例：`/index.php (Status: 200) [Size: 245]`

- パス（例 `/index.php`）  
    → 見つかったファイル／ディレクトリの場所。
    
- `Status:`（HTTPステータスコード）
    
    - **200** → 「OK。あったよ」。アクセス可能。中身を取れる。
        
    - **301** → 「恒久的に移動したよ（リダイレクト）」。行き先が `-->` の右に表示される。
        
    - **403** → 「アクセス禁止（Forbidden）」。存在はあるが見せない設定。
        
    - **404** → （ここでは表示されない）「存在しない」。ゴブスターは404をネガティブ扱いにしてるので通常出さない。
        
- `Size:` → サーバーが返したレスポンスのバイト数（目安。空でも意味はある）。
    
- `--> http://192.168.56.102/admin/`（リダイレクト先）  
    → 301のとき、実際の行き先を示す。
    

---

### 各行をあなたの結果に当てはめると

- `/.htpasswd (Status: 403)`  
    → `.htpasswd` ファイルがある（認証用のユーザー情報ファイル）けど見せない設定。これは「ベーシック認証」が仕込まれている可能性のサイン。
    
- `/admin (Status: 301) [--> /admin/]`  
    → `/admin` にアクセスしたら `/admin/` にリダイレクトされる。管理画面っぽい入口があると示唆。中を見に行く価値あり（ただし許可がある環境で）。
    
- `/.hta (Status: 403)`、`/.htaccess (Status: 403)`  
    → サーバー設定ファイルが存在しているが閲覧不可。`.htaccess` はApacheの設定ファイルで、アクセス制御のルールがここにある場合が多い。
    
- `/index.php (Status: 200)`  
    → 一番普通のページ（トップページ）が取れる。中身を見てアプリの種類やパラメータを探る。
    
- `/server-status (Status: 403)`  
    → Apacheの `server-status`（サーバ状況表示）が有効になっている可能性があるが、403でブロックされている。設定ミスだと情報が見えることがある。
    

---

### 「wordlists」って何？

`wordlist` は「試す名前の辞書」だよ。

- 例えば `common.txt` は「よく使われるディレクトリ名／ファイル名」を並べたリスト。
    
- gobuster はそのリストを1行ずつ読み込んで `http://target/<単語>` を叩いて、あれば返答を記録する。
    
- つまり「そのサーバーにどんな隠し入口があるか」を辞書引きするイメージ。
    
- 別のワードリスト（もっと長いもの、拡張子をつけたりするもの）を使うと、違う入口が見つかることもある。
    

代表的な使い方例（参考コマンド、許可のある環境でのみ）：

- `gobuster dir -u http://192.168.56.102 -w /path/to/wordlist.txt -t 50`（スレッド数増やす）
    
- `gobuster dir -u http://192.168.56.102 -w common.txt -x php,html,txt`（拡張子を付けて探す）
    
- `curl -I http://192.168.56.102/admin/`（ヘッダだけ見てリダイレクト先や認証の有無を確認）
    

---

### 次にやると良いこと（エネルギー的に整えて安全に）

1. **`index.php` をブラウザで開く**して挙動を観察（フォームやパラメータがないか）。
    
2. **/admin/ にヘッダ確認**（`curl -I -L URL`）してリダイレクト先や認証ヘッダ（`WWW-Authenticate`）を確認。
    
3. **.htpasswd / .htaccess の存在**は認証やアクセス制御があるサイン。無断で突破しないでね（必ず許可のある環境でのみ）。
    
4. **別のワードリストや拡張子指定で再実行**すると他のドア（例えば `/uploads/` `/backup/`）が見つかることがある。
    

---

最後にエネルギー的な一言：  
サーバーは静かに「見つけてくれ」と囁いてる。でも敬意を持って触ること。許可のない探索は人の波動を乱すから、必ず許可がある環境（自分のラボ／許可済みの範囲）で遊んでね。🧘‍♂️✨

もっと深掘りしてほしい？（例：`curl`出力の見方、具体的なgobusterオプション、別ワードリストのおすすめ）そのまま教えるよ — どの方向に波を飛ばす？

そのワードリストはもともと入ってるの？
答え：多くのペネトレーション検査向けの環境（Kali など）では、その `common.txt` は最初から入ってることが多い。

**dirbって何？**  
簡単にいうと「ウェブサイトの扉を辞書で片っ端からノックするツール」だよ。指定したワードリスト（wordlist）の単語を順に `/単語` としてリクエストを投げ、存在するページやディレクトリを見つけ出す。ゴブスターと似てるけど、歴史ある古参ツールの一つ。

`-u` の語源はシンプルに **“URL” の頭文字** だよ。
gobuster はコマンドラインで「何を探すか」を指定する必要がある

gobusterとdirbの関係
と、**gobuster と dirb は兄弟みたいな関係**
- dirb = 「丁寧にノックするおじいちゃん」
    
- gobuster = 「多腕で高速ノックする若手ヒーロー」

今回、同じコマンドに二人いるけど？

### 結論（まず短く）

- `gobuster` が「ノックする人」
    
- `dirb/common.txt` は「持ってる単語帳（ワードリスト）」で、**元は `dirb` という別ツールに同梱されている辞書が置かれているフォルダ名**に過ぎない。  
    だからコマンドに **“二人” がいるように見える**けど、実際には **1人が動いて（gobuster）、もう1人の名札（dirb の wordlist）を借りてる**状態。
- `gobuster` は実行バイナリ（ツール）。
    
- `-w /usr/share/wordlists/dirb/common.txt` で指定しているのは単なる **ファイルパス**。そのファイルが `dirb` パッケージに同梱されていることが多いから、パスに `dirb` と書かれているだけ。
    
- 別に gobuster は `dirb` と仲良しとか依存してるわけじゃない。**どのツールでも、好きなワードリストファイルをポイントすれば使える**。

「gobuster（実働）」＋「dirbフォルダにあるワードリスト（道具）」のコンビ。


##= admin/ ログインできない
→php.bak のソースコードをよく読み
php固有のstrcmp（）の弱点をつかむ

usenameにadmin, passwdに配列を入れればいい


認証情報はpostリクエストを渡しているので、burp suiteを使う


Contenu du fichier ../../../../../etc/passwd :  
「**Contenu du fichier**」はフランス語で、直訳すると…

**「ファイルの内容」**

- **Contenu** = 内容、コンテンツ
    
- **du** = of the（「de + le」の縮約形）
    
- **fichier** = ファイル
    

つまり、プログラムや画面でこれが出てたら、単純に「このファイルの中身を表示しますよ」
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/usr/sbin/nologin
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
mail:x:8:8:mail:/var/mail:/usr/sbin/nologin
news:x:9:9:news:/var/spool/news:/usr/sbin/nologin
uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin
proxy:x:13:13:proxy:/bin:/usr/sbin/nologin
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
backup:x:34:34:backup:/var/backups:/usr/sbin/nologin
list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin
irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin
gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin
nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin
systemd-network:x:100:102:systemd Network Management,,,:/run/systemd:/usr/sbin/nologin
systemd-resolve:x:101:103:systemd Resolver,,,:/run/systemd:/usr/sbin/nologin
systemd-timesync:x:102:104:systemd Time Synchronization,,,:/run/systemd:/usr/sbin/nologin
messagebus:x:103:106::/nonexistent:/usr/sbin/nologin
syslog:x:104:110::/home/syslog:/usr/sbin/nologin
_apt:x:105:65534::/nonexistent:/usr/sbin/nologin
tss:x:106:111:TPM software stack,,,:/var/lib/tpm:/bin/false
uuidd:x:107:112::/run/uuidd:/usr/sbin/nologin
tcpdump:x:108:113::/nonexistent:/usr/sbin/nologin
landscape:x:109:115::/var/lib/landscape:/usr/sbin/nologin
pollinate:x:110:1::/var/cache/pollinate:/bin/false
sshd:x:111:65534::/run/sshd:/usr/sbin/nologin
systemd-coredump:x:999:999:systemd Core Dumper:/:/usr/sbin/nologin
florianges:x:1000:1000:florianges:/home/florianges:/bin/bash
lxd:x:998:100::/var/snap/lxd/common/lxd:/bin/false
proftpd:x:112:65534::/run/proftpd:/usr/sbin/nologin
ftp:x:113:65534::/srv/ftp:/usr/sbin/nologin
webadmin:$1$webadmin$3sXBxGUtDGIFAcnNTNhi6/:1001:1001:webadmin,,,:/home/webadmin:/bin/bash

logsページってなに
- **logs = 記録**
    
- サーバーやアプリが「誰がいつどんなことをしたか」を記録しているページ。

POST /admin/dashboard.php?page=log HTTP/1.1
Host: 192.168.56.102
Content-Length: 15
Cache-Control: max-age=0
Accept-Language: en-US,en;q=0.9
Origin: http://192.168.56.102
Content-Type: application/x-www-form-urlencoded
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.0.0 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
Referer: http://192.168.56.102/admin/dashboard.php?page=log
Accept-Encoding: gzip, deflate, br
Cookie: pass=serdesfsefhijosefjtfgyuhjiosefdfthgyjh
Connection: keep-alive

file=log_01.txt　　これを解説してほしい

おお〜、やっとHTTPの波動が見えてきたね✨  
これはサーバーに「何かを送って結果をもらうリクエスト」の典型的な例だよ。スピリチュアル＋コメディ的に解説するね。😆

---

### ざっくり言うと

- **あなたがサーバーに手紙を送っている状態**
    
- POST メソッドを使って「file=log_01.txt」というデータを送り、サーバーの `/admin/dashboard.php` にある `page=log` のページに処理をお願いしている
    
- サーバーはその日記帳（logs）を読んで、結果を返す感じ
    

---

### 各部分を噛み砕く

1. **リクエストライン**
    

```
POST /admin/dashboard.php?page=log HTTP/1.1
```

- `POST` → データを送信するよ
    
- `/admin/dashboard.php?page=log` → ダッシュボードのログページにデータを送っている
    
- `HTTP/1.1` → プロトコルのバージョン
    

2. **ヘッダ部分（User-AgentとかHost）**
    

- `Host: 192.168.56.102` → 送る相手（家の住所）
    
- `Content-Length: 15` → 今から送るデータの長さ（文字数）
    
- `Content-Type: application/x-www-form-urlencoded` → 送信データの形式。「key=value」の形で送る
    
- `Cookie: pass=…` → サーバーに「私ログインしてるよ」と伝える印鑑
    

3. **ボディ部分**
    

```
file=log_01.txt
```

- 送っている中身（データ）。
    
- 「どのログファイルを見たいか」をサーバーにお願いしてる感じ
    
- PHP側では `$_POST['file'] == 'log_01.txt'` になる
    

---

### 波動的イメージ

- あなた（ブラウザ） → 手紙を送る
    
- サーバー → 日記帳を持っている管理者
    
- POST → 手紙にお願いを書く
    
- file=log_01.txt → 「この日のログを見せて！」というリクエスト
    

---

💡 コメディ補足

- もしこのリクエストが攻撃者に見られたら…  
    → 「誰のログ見ようとしてるんだい？😏」ってサーバーがこっそり笑ってる感じ。
    
- POST の波動は GET より強めで「行動を起こす魔法」のイメージ。
    

---
だかえこのページでサーバーとやりとりしているから

サーバーのetc/passwdにもアクセスできるわけか
また、
- `../` だけだと「一段上」のみアクセス。
    
- でも教科書的には、目的のファイルやディレクトリがさらに上にあることが多いので、いきなり二段上から始める方が効率的。

- あなたが今いるのは `/admin/dashboard.php?page=log` のページ。これはファイル `dashboard.php` が `admin` フォルダにある感じ。
    
- `../` は一段上に戻るので、`/admin/`（フォルダ）に行く。  
    → まだ `admin` の世界にいる。
なぜ二段上を最初に試すか」は効率と経験則だけど、実際の成否は**サーバー側の実装**次第。
ブラウザのURLパス上で `../` を使うのと、サーバーが受け取ったパラメータ（例：`file=...`）をファイルパスに結合してから処理するのとでは意味が違う。
1. - `..` の連続を検知してブロックする仕組みがあると、段数を増やす作戦自体が検出対象になることもある（防御側の対策）。
        

---

### 教科書が「二段目から始める」理由（整理）

- **効率**：一段ずつやるより「いきなり少し深め」に飛んで到達する確率を上げるため。
- **実務経験**：重要ファイルは単に一段上には置かれていないことが多く、より上を狙う必要があるため。

$ cat pass.txt | grep -P 'sh$'
### `-P` の意味と語源（由来）

- `-P` は **Perl-compatible regular expressions**（PCRE）を使うためのフラグ。
- **Perl-compatible（Perl互換）**

- Perl というプログラミング言語で作られた、超強力な正規表現の書き方に合わせていること。
- `sh$` → 「行の最後が sh で終わる行」という意味の呪文。regular expressions（正規表現）

`ssh webadmin@$IP` は **SSHでリモートに接続するときに「webadmin」というユーザー名で `$IP`（相手のIPアドレス）に入る** 命令だよ
- `ssh`：安全にリモートのマシンに入るためのコマンド（Secure SHell）。
    
- `webadmin@`：接続先で使う**ユーザー名**。ここで指定したアカウントでログインを試みる。
    
- `$IP`：接続先の**ホスト名**か**IPアドレス**。環境変数の形で書いているだけで、実行時は具体的な値に展開される。

base64 -d
base64：文字列を Base64 形式に変換したり戻したりするコマンド

-d：デコード（decode）するためのオプション


### 流れをイメージで言うと

ウェブページから、
ファイルを盗むetc/passwd
そこからwebadminのパスワードをjohnでクラックして
それでsshに入る
そこからガチャガチャしてルートファイル
